diff --git a/src/JsonlToMarkdownConverter.ts b/src/JsonlToMarkdownConverter.ts
index 89dd052..9a76b91 100644
--- a/src/JsonlToMarkdownConverter.ts
+++ b/src/JsonlToMarkdownConverter.ts
@@ -1,11 +1,10 @@
 import { readFileSync } from 'node:fs'
 import type { Entry, Item, StateType } from './types.ts'
 import { EntrySchema } from './types.ts'
-import { CommandParser } from './CommandParser.ts'
-import { ToolResultFormatter } from './ToolResultFormatter.ts'
-import { assert, createImageFile } from './utils.ts'
-import type { Content, ToolUseResult } from './types.ts'
+import { assert } from './utils.ts'
 import { basename } from 'node:path'
+import { OutputFormatter, type FormatterContext } from './OutputFormatter.ts'
+import { CommandParser } from './CommandParser.ts'
 
 export class JsonlToMarkdownConverter {
   private itemTree = new Map<string, Item>()
@@ -15,9 +14,17 @@ export class JsonlToMarkdownConverter {
   private metaEntry: Entry | null = null
   private lastTimestamp: string | null = null
   private firstUserPrompt: string | null = null
+  private outputFormatter: OutputFormatter
 
   constructor(isDebug: boolean = false) {
     this.isDebug = isDebug
+    // Create formatter with initial context (will be updated later with actual maps)
+    this.outputFormatter = new OutputFormatter({
+      toolUseTree: new Map(),
+      itemTree: new Map(),
+      defaultSaveOnly: false,
+      isDebug: isDebug,
+    })
   }
 
   convert(jsonlPath: string): { content: string; filename: string } | null {
@@ -27,6 +34,14 @@ export class JsonlToMarkdownConverter {
     const entries = this.parseJsonlFile(jsonlPath)
     this.buildItemTree(entries)
 
+    // Create new OutputFormatter with complete context
+    this.outputFormatter = new OutputFormatter({
+      toolUseTree: this.toolUseTree,
+      itemTree: this.itemTree,
+      defaultSaveOnly: false,
+      isDebug: this.isDebug,
+    })
+
     const markdownSections = this.processEntries()
 
     if (markdownSections.length === 0) {
@@ -227,7 +242,7 @@ export class JsonlToMarkdownConverter {
       entry.type === 'user' && entry.isSidechain ? 'assistant' : entry.type
 
     if (typeof entry.message.content === 'string') {
-      const text = this.formatTextContent(
+      const text = this.outputFormatter.formatTextContent(
         item,
         entry.message.content,
         entryType,
@@ -237,7 +252,7 @@ export class JsonlToMarkdownConverter {
       entry.message.content.forEach((contentItem, index) => {
         if (index > 0) output.push('')
 
-        const formattedContent = this.formatContentItem(
+        const formattedContent = this.outputFormatter.formatContentItem(
           item,
           contentItem,
           entryType,
@@ -254,184 +269,6 @@ export class JsonlToMarkdownConverter {
     return output.length > 0 ? output.join('\n') : null
   }
 
-  private formatContentItem(
-    item: Item,
-    contentItem: Content,
-    entryType: string,
-  ): string | null {
-    switch (contentItem.type) {
-      case 'text':
-        return contentItem.text
-          ? this.formatTextContent(item, contentItem.text, entryType)
-          : null
-      case 'tool_use':
-        return this.formatToolUse(item, contentItem)
-      case 'image':
-        return this.formatImage(item, contentItem)
-      default:
-        console.warn(
-          `Unhandled content type "${contentItem.type}" on line #${item.lineNumber}`,
-        )
-        return null
-    }
-  }
-
-  private formatTextContent(
-    item: Item,
-    text: string,
-    entryType: string,
-  ): string | null {
-    if (text === '(no content)') {
-      console.warn(`Skipping empty content on line #${item.lineNumber}`)
-      return null
-    }
-
-    const output: string[] = []
-    const parser = new CommandParser(text)
-    if (parser.hasCommandElements()) {
-      const parsed = parser.parse()
-      if (parsed) output.push(...parsed)
-    } else if (entryType === 'user') {
-      output.push(...this.formatUserMessage(text))
-    } else if (entryType === 'assistant') {
-      // just output assistant messages as-is
-      output.push(text)
-    } else {
-      output.push(
-        `## Unknown entry type ${entryType} on line #${item.lineNumber}`,
-      )
-      output.push('```json')
-      output.push(JSON.stringify(item.entry, null, 2))
-      output.push('```')
-    }
-
-    return output.length > 0 ? output.join('\n') : null
-  }
-
-  private formatUserMessage(text: string): string[] {
-    const output: string[] = []
-    // user messages are rendered as blockquotes
-    // add special notice for certain messages
-    if (text.startsWith('[Request interrupted')) {
-      output.push(`> [!WARNING]`)
-    } else if (text.startsWith("Error: The user doesn't want to proceed")) {
-      output.push(`> [!CAUTION]`)
-    } else {
-      output.push(`> [!IMPORTANT]`)
-    }
-
-    const lines = text.split('\n')
-    output.push(...lines.map((line) => `> ${line}`))
-
-    return output
-  }
-
-  private formatToolUse(item: Item, contentItem: Content): string {
-    const output: string[] = []
-    const toolName = contentItem.name || 'Unknown Tool'
-    const description = this.getToolDescription(contentItem)
-
-    output.push(
-      `${this.getToolEmoji(toolName)} **${toolName}${description ? `: ${description}` : ''}**`,
-    )
-
-    if (contentItem.input?.command) {
-      output.push(`\`\`\`shell\n${contentItem.input.command}\n\`\`\``)
-    }
-    if (contentItem.input?.prompt) {
-      output.push(`\n${contentItem.input.prompt}`)
-    }
-
-    // Process tool results
-    const toolUseId = contentItem.id || ''
-    const toolResults = this.toolUseTree.get(toolUseId) || []
-
-    toolResults.forEach((result, index) => {
-      assert(result.uuid, 'Tool result entry is missing UUID')
-
-      // separate multiple results with a blank line
-      if (index > 0) output.push('')
-
-      const resultItem = this.itemTree.get(result.uuid)
-      if (!resultItem) {
-        console.warn(
-          `Tool result with UUID ${result.uuid} not found in ItemTree`,
-        )
-        return
-      }
-
-      if (result.toolUseResult) {
-        const formattedResult = this.formatToolResult(
-          toolName,
-          resultItem,
-          result.toolUseResult as ToolUseResult,
-        )
-        if (formattedResult) output.push(formattedResult)
-      } else {
-        output.push(
-          `## Tool result for tool_use_id ${toolUseId} on line #${item.lineNumber} at line #${resultItem.lineNumber}`,
-        )
-        output.push('```json')
-        output.push(JSON.stringify(result, null, 2))
-        output.push('```')
-      }
-    })
-
-    return output.join('\n')
-  }
-
-  private formatToolResult(
-    toolName: string,
-    resultItem: Item,
-    toolUseResult: ToolUseResult,
-  ): string {
-    const output: string[] = []
-    const formatter = new ToolResultFormatter(toolName, this.isDebug)
-
-    if (this.isDebug) {
-      output.push(
-        `### Tool Use Result for ${toolName} on line #${resultItem.lineNumber} (isSidechain: ${resultItem.entry.isSidechain})`,
-      )
-    }
-
-    const formatted = formatter.format(toolUseResult, resultItem)
-    if (formatted) output.push(formatted)
-
-    resultItem.state = 'processed'
-    return output.join('\n')
-  }
-
-  private formatImage(item: Item, contentItem: Content): string | null {
-    if (
-      contentItem.type === 'image' &&
-      contentItem.source &&
-      contentItem.source.type === 'base64' &&
-      typeof contentItem.source.data === 'string'
-    ) {
-      const filename = createImageFile(
-        contentItem.source.data,
-        contentItem.source.media_type,
-        item.uuid,
-      )
-      return `![Image](contents/${filename})`
-    }
-
-    return [
-      `## Unhandled image content on line #${item.lineNumber}`,
-      '```json',
-      JSON.stringify(contentItem, null, 2),
-      '```',
-    ].join('\n')
-  }
-
-  private getToolDescription(contentItem: Content): string {
-    const input = contentItem.input
-    if (!input) return ''
-
-    if (input.pattern) return `\`"${input.pattern.replace(/\\/g, '\\')}"\``
-    return input.description || input.path || input.file_path || input.url || ''
-  }
-
   private getToolUseId(entry: Entry): string | null {
     const content = entry?.message?.content
     if (Array.isArray(content)) {
@@ -456,23 +293,6 @@ export class JsonlToMarkdownConverter {
     return null
   }
 
-  private getToolEmoji(toolName: string): string {
-    const emojiMap: { [key: string]: string } = {
-      ls: 'üìÇ',
-      read: 'üìñ',
-      write: '‚úçÔ∏è',
-      edit: '‚úèÔ∏è',
-      multiedit: '‚úèÔ∏è',
-      glob: 'üîç',
-      grep: 'üîç',
-      task: 'üìã',
-      todowrite: '‚úÖ',
-      bash: 'üíª',
-      webfetch: 'üåê',
-    }
-    return emojiMap[toolName.toLowerCase()] || 'üõ†Ô∏è'
-  }
-
   private generateHeader(): string | null {
     if (!this.metaEntry || !this.metaEntry.cwd) {
       return null
@@ -480,14 +300,14 @@ export class JsonlToMarkdownConverter {
 
     const lines: string[] = [
       '# ü§ñ Claude Code Transcript',
-      `## üóÇÔ∏è ${this.formatPath(this.metaEntry.cwd)}`,
+      `## üóÇÔ∏è ${this.outputFormatter.formatPath(this.metaEntry.cwd)}`,
     ]
 
     // Format timestamps
     if (this.metaEntry.timestamp) {
-      const startTime = this.formatTimestamp(this.metaEntry.timestamp)
+      const startTime = this.outputFormatter.formatTimestamp(this.metaEntry.timestamp)
       const endTime = this.lastTimestamp
-        ? this.formatTimestamp(this.lastTimestamp)
+        ? this.outputFormatter.formatTimestamp(this.lastTimestamp)
         : startTime
       lines.push(`üïí ${startTime} - ${endTime}`)
     }
@@ -495,24 +315,6 @@ export class JsonlToMarkdownConverter {
     return lines.join('\n')
   }
 
-  private formatPath(cwd: string): string {
-    // Replace user home directory with ~
-    const homeDir = process.env.HOME || process.env.USERPROFILE || ''
-    if (homeDir && cwd.startsWith(homeDir)) {
-      return cwd.replace(homeDir, '~')
-    }
-    return cwd
-  }
-
-  private formatTimestamp(timestamp: string): string {
-    // Convert ISO timestamp to readable format without T and Z
-    const date = new Date(timestamp)
-    return date
-      .toISOString()
-      .replace(/\.\d{3}Z$/, '') // Remove milliseconds and Z
-      .replace('T', ' ') // Replace T with space
-  }
-
   private generateFilename(filePath: string): string {
     // Use meta entry timestamp or fallback to current date
     const timestamp = this.metaEntry?.timestamp || new Date().toISOString()
diff --git a/src/OutputFormatter.ts b/src/OutputFormatter.ts
index 6253af7..cdd103f 100644
--- a/src/OutputFormatter.ts
+++ b/src/OutputFormatter.ts
@@ -1,13 +1,31 @@
 import { writeFileSync } from 'node:fs'
 import { join, basename } from 'node:path'
 import { createHash } from 'node:crypto'
-import { filterAnsi, truncateLine, escapeCodeFences, trimBlankLines, getLanguageFromExtension } from './utils.ts'
+import {
+  filterAnsi,
+  truncateLine,
+  escapeCodeFences,
+  trimBlankLines,
+  getLanguageFromExtension,
+  createImageFile,
+  assert,
+} from './utils.ts'
+import type { Item, Content, ToolUseResult, Entry } from './types.ts'
+import { CommandParser } from './CommandParser.ts'
+import { ToolResultFormatter } from './ToolResultFormatter.ts'
+
+export interface FormatterContext {
+  toolUseTree: Map<string, Entry[]>
+  itemTree: Map<string, Item>
+  defaultSaveOnly: boolean
+  isDebug: boolean
+}
 
 export class OutputFormatter {
-  private defaultSaveOnly: boolean
+  private context: FormatterContext
 
-  constructor(defaultSaveOnly: boolean) {
-    this.defaultSaveOnly = defaultSaveOnly
+  constructor(context: FormatterContext) {
+    this.context = context
   }
 
   format(options: {
@@ -19,7 +37,7 @@ export class OutputFormatter {
     label?: string
   }): string {
     const {
-      saveOnly = this.defaultSaveOnly,
+      saveOnly = this.context.defaultSaveOnly,
       content,
       fileContent,
       filePath,
@@ -155,4 +173,216 @@ export class OutputFormatter {
 
     return join('contents', filename)
   }
-}
\ No newline at end of file
+
+  formatTextContent(
+    item: Item,
+    text: string,
+    entryType: string,
+  ): string | null {
+    if (text === '(no content)') {
+      console.warn(`Skipping empty content on line #${item.lineNumber}`)
+      return null
+    }
+
+    const output: string[] = []
+    const parser = new CommandParser(text)
+    if (parser.hasCommandElements()) {
+      const parsed = parser.parse()
+      if (parsed) output.push(...parsed)
+    } else if (entryType === 'user') {
+      output.push(...this.formatUserMessage(text))
+    } else if (entryType === 'assistant') {
+      // just output assistant messages as-is
+      output.push(text)
+    } else {
+      output.push(
+        `## Unknown entry type ${entryType} on line #${item.lineNumber}`,
+      )
+      output.push('```json')
+      output.push(JSON.stringify(item.entry, null, 2))
+      output.push('```')
+    }
+
+    return output.length > 0 ? output.join('\n') : null
+  }
+
+  formatUserMessage(text: string): string[] {
+    const output: string[] = []
+    // user messages are rendered as blockquotes
+    // add special notice for certain messages
+    if (text.startsWith('[Request interrupted')) {
+      output.push(`> [!WARNING]`)
+    } else if (text.startsWith("Error: The user doesn't want to proceed")) {
+      output.push(`> [!CAUTION]`)
+    } else {
+      output.push(`> [!IMPORTANT]`)
+    }
+
+    const lines = text.split('\n')
+    output.push(...lines.map((line) => `> ${line}`))
+
+    return output
+  }
+
+  formatContentItem(
+    item: Item,
+    contentItem: Content,
+    entryType: string,
+  ): string | null {
+    switch (contentItem.type) {
+      case 'text':
+        return contentItem.text
+          ? this.formatTextContent(item, contentItem.text, entryType)
+          : null
+      case 'tool_use':
+        return this.formatToolUse(item, contentItem)
+      case 'image':
+        return this.formatImage(item, contentItem)
+      default:
+        console.warn(
+          `Unhandled content type "${contentItem.type}" on line #${item.lineNumber}`,
+        )
+        return null
+    }
+  }
+
+  formatToolUse(item: Item, contentItem: Content): string {
+    const output: string[] = []
+    const toolName = contentItem.name || 'Unknown Tool'
+    const description = this.getToolDescription(contentItem)
+
+    output.push(
+      `${this.getToolEmoji(toolName)} **${toolName}${description ? `: ${description}` : ''}**`,
+    )
+
+    if (contentItem.input?.command) {
+      output.push(`\`\`\`shell\n${contentItem.input.command}\n\`\`\``)
+    }
+    if (contentItem.input?.prompt) {
+      output.push(`\n${contentItem.input.prompt}`)
+    }
+
+    // Process tool results
+    const toolUseId = contentItem.id || ''
+    const toolResults = this.context?.toolUseTree.get(toolUseId) || []
+
+    toolResults.forEach((result, index) => {
+      assert(result.uuid, 'Tool result must have a UUID')
+      // separate multiple results with a blank line
+      if (index > 0) output.push('')
+
+      const resultItem = this.context?.itemTree.get(result.uuid)
+      if (!resultItem) {
+        console.warn(
+          `Tool result with UUID ${result.uuid} not found in ItemTree`,
+        )
+        return
+      }
+
+      if (result.toolUseResult) {
+        const formattedResult = this.formatToolResult(
+          toolName,
+          resultItem,
+          result.toolUseResult as ToolUseResult,
+        )
+        if (formattedResult) output.push(formattedResult)
+      } else {
+        output.push(
+          `## Tool result for tool_use_id ${toolUseId} on line #${item.lineNumber} at line #${resultItem.lineNumber}`,
+        )
+        output.push('```json')
+        output.push(JSON.stringify(result, null, 2))
+        output.push('```')
+      }
+    })
+
+    return output.join('\n')
+  }
+
+  formatToolResult(
+    toolName: string,
+    resultItem: Item,
+    toolUseResult: ToolUseResult,
+  ): string {
+    const output: string[] = []
+    const formatter = new ToolResultFormatter(toolName, this)
+
+    if (this.context.isDebug) {
+      output.push(
+        `### Tool Use Result for ${toolName} on line #${resultItem.lineNumber} (isSidechain: ${resultItem.entry.isSidechain})`,
+      )
+    }
+
+    const formatted = formatter.format(toolUseResult, resultItem)
+    if (formatted) output.push(formatted)
+
+    resultItem.state = 'processed'
+    return output.join('\n')
+  }
+
+  formatImage(item: Item, contentItem: Content): string | null {
+    if (
+      contentItem.type === 'image' &&
+      contentItem.source &&
+      contentItem.source.type === 'base64' &&
+      typeof contentItem.source.data === 'string'
+    ) {
+      const filename = createImageFile(
+        contentItem.source.data,
+        contentItem.source.media_type,
+        item.uuid,
+      )
+      return `![Image](contents/${filename})`
+    }
+
+    return [
+      `## Unhandled image content on line #${item.lineNumber}`,
+      '```json',
+      JSON.stringify(contentItem, null, 2),
+      '```',
+    ].join('\n')
+  }
+
+  getToolDescription(contentItem: Content): string {
+    const input = contentItem.input
+    if (!input) return ''
+
+    if (input.pattern) return `\`"${input.pattern.replace(/\\/g, '\\')}"\``
+    return input.description || input.path || input.file_path || input.url || ''
+  }
+
+  getToolEmoji(toolName: string): string {
+    const emojiMap: { [key: string]: string } = {
+      ls: 'üìÇ',
+      read: 'üìñ',
+      write: '‚úçÔ∏è',
+      edit: '‚úèÔ∏è',
+      multiedit: '‚úèÔ∏è',
+      glob: 'üîç',
+      grep: 'üîç',
+      task: 'üìã',
+      todowrite: '‚úÖ',
+      bash: 'üíª',
+      webfetch: 'üåê',
+    }
+    return emojiMap[toolName.toLowerCase()] || 'üõ†Ô∏è'
+  }
+
+  formatPath(cwd: string): string {
+    // Replace user home directory with ~
+    const homeDir = process.env.HOME || process.env.USERPROFILE || ''
+    if (homeDir && cwd.startsWith(homeDir)) {
+      return cwd.replace(homeDir, '~')
+    }
+    return cwd
+  }
+
+  formatTimestamp(timestamp: string): string {
+    // Convert ISO timestamp to readable format without T and Z
+    const date = new Date(timestamp)
+    return date
+      .toISOString()
+      .replace(/\.\d{3}Z$/, '') // Remove milliseconds and Z
+      .replace('T', ' ') // Replace T with space
+  }
+}
diff --git a/src/ToolResultFormatter.ts b/src/ToolResultFormatter.ts
index 04334bd..efcabfa 100644
--- a/src/ToolResultFormatter.ts
+++ b/src/ToolResultFormatter.ts
@@ -6,15 +6,15 @@ import type {
   Todo,
   ToolUseResult,
 } from './types.ts'
-import { OutputFormatter } from './OutputFormatter.ts'
+import type { OutputFormatter } from './OutputFormatter.ts'
 
 export class ToolResultFormatter {
   private toolName: string
-  private isDebug: boolean
+  private outputFormatter: OutputFormatter
 
-  constructor(toolName: string, isDebug: boolean) {
+  constructor(toolName: string, outputFormatter: OutputFormatter) {
     this.toolName = toolName
-    this.isDebug = isDebug
+    this.outputFormatter = outputFormatter
   }
 
   format(toolUseResult: ToolUseResult, resultItem: Item): string | null {
@@ -136,8 +136,10 @@ export class ToolResultFormatter {
     codeFence?: boolean
     label?: string
   }): string {
-    const output = new OutputFormatter(this.shouldSaveOnly())
-    return output.format(options)
+    return this.outputFormatter.format({
+      ...options,
+      saveOnly: this.shouldSaveOnly(),
+    })
   }
 
   private shouldSaveOnly(): boolean {