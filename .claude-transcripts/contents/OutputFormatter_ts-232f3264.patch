diff --git a/Users/michael/Projects/oss/claude-transcript/src/OutputFormatter.ts b/Users/michael/Projects/oss/claude-transcript/src/OutputFormatter.ts
index 1234567..abcdefg 100644
--- a/Users/michael/Projects/oss/claude-transcript/src/OutputFormatter.ts
+++ b/Users/michael/Projects/oss/claude-transcript/src/OutputFormatter.ts
@@ -160,4 +160,207 @@
 
     return join('contents', filename)
   }
+
+  formatTextContent(
+    item: Item,
+    text: string,
+    entryType: string,
+  ): string | null {
+    if (text === '(no content)') {
+      console.warn(`Skipping empty content on line #${item.lineNumber}`)
+      return null
+    }
+
+    const output: string[] = []
+    const parser = new CommandParser(text)
+    if (parser.hasCommandElements()) {
+      const parsed = parser.parse()
+      if (parsed) output.push(...parsed)
+    } else if (entryType === 'user') {
+      output.push(...this.formatUserMessage(text))
+    } else if (entryType === 'assistant') {
+      // just output assistant messages as-is
+      output.push(text)
+    } else {
+      output.push(
+        `## Unknown entry type ${entryType} on line #${item.lineNumber}`,
+      )
+      output.push('```json')
+      output.push(JSON.stringify(item.entry, null, 2))
+      output.push('```')
+    }
+
+    return output.length > 0 ? output.join('\n') : null
+  }
+
+  formatUserMessage(text: string): string[] {
+    const output: string[] = []
+    // user messages are rendered as blockquotes
+    // add special notice for certain messages
+    if (text.startsWith('[Request interrupted')) {
+      output.push(`> [!WARNING]`)
+    } else if (text.startsWith("Error: The user doesn't want to proceed")) {
+      output.push(`> [!CAUTION]`)
+    } else {
+      output.push(`> [!IMPORTANT]`)
+    }
+
+    const lines = text.split('\n')
+    output.push(...lines.map((line) => `> ${line}`))
+
+    return output
+  }
+
+  formatContentItem(
+    item: Item,
+    contentItem: Content,
+    entryType: string,
+  ): string | null {
+    switch (contentItem.type) {
+      case 'text':
+        return contentItem.text
+          ? this.formatTextContent(item, contentItem.text, entryType)
+          : null
+      case 'tool_use':
+        return this.formatToolUse(item, contentItem)
+      case 'image':
+        return this.formatImage(item, contentItem)
+      default:
+        console.warn(
+          `Unhandled content type "${contentItem.type}" on line #${item.lineNumber}`,
+        )
+        return null
+    }
+  }
+
+  formatToolUse(item: Item, contentItem: Content, toolUseTree: Map<string, any[]>): string {
+    const output: string[] = []
+    const toolName = contentItem.name || 'Unknown Tool'
+    const description = this.getToolDescription(contentItem)
+
+    output.push(
+      `${this.getToolEmoji(toolName)} **${toolName}${description ? `: ${description}` : ''}**`,
+    )
+
+    if (contentItem.input?.command) {
+      output.push(`\`\`\`shell\n${contentItem.input.command}\n\`\`\``)
+    }
+    if (contentItem.input?.prompt) {
+      output.push(`\n${contentItem.input.prompt}`)
+    }
+
+    // Process tool results
+    const toolUseId = contentItem.id || ''
+    const toolResults = toolUseTree.get(toolUseId) || []
+
+    toolResults.forEach((result, index) => {
+      // separate multiple results with a blank line
+      if (index > 0) output.push('')
+
+      if (result.toolUseResult) {
+        const formattedResult = this.formatToolResult(
+          toolName,
+          result,
+          result.toolUseResult as ToolUseResult,
+        )
+        if (formattedResult) output.push(formattedResult)
+      } else {
+        output.push(
+          `## Tool result for tool_use_id ${toolUseId} on line #${item.lineNumber}`,
+        )
+        output.push('```json')
+        output.push(JSON.stringify(result, null, 2))
+        output.push('```')
+      }
+    })
+
+    return output.join('\n')
+  }
+
+  formatToolResult(
+    toolName: string,
+    resultItem: any,
+    toolUseResult: ToolUseResult,
+  ): string {
+    const output: string[] = []
+    const formatter = new ToolResultFormatter(toolName, this.isDebug)
+
+    if (this.isDebug) {
+      output.push(
+        `### Tool Use Result for ${toolName} on line #${resultItem.lineNumber} (isSidechain: ${resultItem.entry.isSidechain})`,
+      )
+    }
+
+    const formatted = formatter.format(toolUseResult, resultItem)
+    if (formatted) output.push(formatted)
+
+    resultItem.state = 'processed'
+    return output.join('\n')
+  }
+
+  formatImage(item: Item, contentItem: Content): string | null {
+    if (
+      contentItem.type === 'image' &&
+      contentItem.source &&
+      contentItem.source.type === 'base64' &&
+      typeof contentItem.source.data === 'string'
+    ) {
+      const filename = createImageFile(
+        contentItem.source.data,
+        contentItem.source.media_type,
+        item.uuid,
+      )
+      return `![Image](contents/${filename})`
+    }
+
+    return [
+      `## Unhandled image content on line #${item.lineNumber}`,
+      '```json',
+      JSON.stringify(contentItem, null, 2),
+      '```',
+    ].join('\n')
+  }
+
+  getToolDescription(contentItem: Content): string {
+    const input = contentItem.input
+    if (!input) return ''
+
+    if (input.pattern) return `\`"${input.pattern.replace(/\\/g, '\\')}"\``
+    return input.description || input.path || input.file_path || input.url || ''
+  }
+
+  getToolEmoji(toolName: string): string {
+    const emojiMap: { [key: string]: string } = {
+      ls: 'ğŸ“‚',
+      read: 'ğŸ“–',
+      write: 'âœï¸',
+      edit: 'âœï¸',
+      multiedit: 'âœï¸',
+      glob: 'ğŸ”',
+      grep: 'ğŸ”',
+      task: 'ğŸ“‹',
+      todowrite: 'âœ…',
+      bash: 'ğŸ’»',
+      webfetch: 'ğŸŒ',
+    }
+    return emojiMap[toolName.toLowerCase()] || 'ğŸ› ï¸'
+  }
+
+  formatPath(cwd: string): string {
+    // Replace user home directory with ~
+    const homeDir = process.env.HOME || process.env.USERPROFILE || ''
+    if (homeDir && cwd.startsWith(homeDir)) {
+      return cwd.replace(homeDir, '~')
+    }
+    return cwd
+  }
+
+  formatTimestamp(timestamp: string): string {
+    // Convert ISO timestamp to readable format without T and Z
+    const date = new Date(timestamp)
+    return date
+      .toISOString()
+      .replace(/\.\d{3}Z$/, '') // Remove milliseconds and Z
+      .replace('T', ' ') // Replace T with space
+  }
 }
\ No newline at end of file