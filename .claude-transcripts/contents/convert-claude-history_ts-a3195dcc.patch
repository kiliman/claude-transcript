diff --git a/Users/michael/Projects/oss/claude-transcript/convert-claude-history.ts b/Users/michael/Projects/oss/claude-transcript/convert-claude-history.ts
index 1234567..abcdefg 100644
--- a/Users/michael/Projects/oss/claude-transcript/convert-claude-history.ts
+++ b/Users/michael/Projects/oss/claude-transcript/convert-claude-history.ts
@@ -392,34 +392,67 @@
 function convertJsonlToMarkdown(jsonlPath: string): string | null {
   const content = readFileSync(jsonlPath, 'utf-8');
   const lines = content.trim().split('\n');
-  const markdownSections: string[] = [];
-
-  let hasValidEntries = false;
-
+  
+  // First pass: Read all entries and build lookup maps
+  const entries: { entry: Entry; lineNumber: number }[] = [];
+  const entriesByParentUuid = new Map<string, { entry: Entry; lineNumber: number }[]>();
+  const processedUuids = new Set<string>();
+  
   lines.forEach((line, index) => {
     if (!line.trim()) return;
-
+    
     try {
       const entry: Entry = JSON.parse(line);
-
-      // Skip meta entries
-      if (entry.isMeta === true) return;
-
-      // Process user and assistant entries
-      if (entry.type === 'user') {
-        const processed = processUserEntry(entry, index + 1);
-        if (processed !== null) {
-          hasValidEntries = true;
-          markdownSections.push(`### Line #${index + 1}\n\n${processed}`);
+      const entryWithLineNumber = { entry, lineNumber: index + 1 };
+      entries.push(entryWithLineNumber);
+      
+      // Build parent lookup map
+      if (entry.parentUuid) {
+        if (!entriesByParentUuid.has(entry.parentUuid)) {
+          entriesByParentUuid.set(entry.parentUuid, []);
         }
-      } else if (entry.type === 'assistant') {
-        hasValidEntries = true;
-        markdownSections.push(`### Line #${index + 1}\n\n${processAssistantEntry(entry, index + 1)}`);
+        entriesByParentUuid.get(entry.parentUuid)!.push(entryWithLineNumber);
       }
     } catch (error) {
       console.error(`Error parsing line ${index + 1} in ${jsonlPath}:`, error);
     }
   });
+  
+  // Second pass: Process entries with access to tool results
+  const markdownSections: string[] = [];
+  let hasValidEntries = false;
+  
+  entries.forEach(({ entry, lineNumber }) => {
+    // Skip if already processed as a child entry
+    if (entry.uuid && processedUuids.has(entry.uuid)) return;
+    
+    // Skip meta entries
+    if (entry.isMeta === true) return;
+    
+    // Process user and assistant entries
+    if (entry.type === 'user') {
+      const processed = processUserEntry(entry, lineNumber);
+      if (processed !== null) {
+        hasValidEntries = true;
+        markdownSections.push(`### Line #${lineNumber}\n\n${processed}`);
+      }
+    } else if (entry.type === 'assistant') {
+      hasValidEntries = true;
+      
+      // Get child entries for tool results
+      const childEntries = entry.uuid ? entriesByParentUuid.get(entry.uuid) || [] : [];
+      
+      const processed = processAssistantEntry(entry, lineNumber, childEntries);
+      markdownSections.push(`### Line #${lineNumber}\n\n${processed}`);
+      
+      // Mark child entries as processed
+      childEntries.forEach(child => {
+        if (child.entry.uuid) {
+          processedUuids.add(child.entry.uuid);
+        }
+      });
+    }
+  });
 
   if (!hasValidEntries) {
     return null;